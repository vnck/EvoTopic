import random
import numpy as np
import copy

class Gene:
  """
  A class used to represent an individual in the population. It contains the hyperparameters for LDA algorithm.

  Attributes
  ----------
  n : int
    the number of topic clusters to be generated by LDA

  a : list
    1D array of length equal to number of topic clusters (n), that expresses our a-priori belief for the each topics’ probability.

  b : list
    1D array of length equal to vocab_size, that expresses our a-priori belief for each word.

  fitness : float
    fitness score of the gene

  vocab_size : int
    the size of the vocabulary of corpus.

  N_MIN : int
    minimum value of n

  N_MAX : int
    maximum value of n

  Methods
  -------
  set_vocab_size(vocab_size)
    static method that sets the value of static variable vocab_size.

  mutate()
    mutates values of n, a, and b.

  set_fitness()
    sets the fitness score of a gene.

  get_fitness()
    returns the fitness score of a gene.

  """

  n = 1
  N_MIN = 4
  N_MAX = 1
  a = []
  b = []
  vocab_size = 0
  fitness = -1

  def __init__(self, n=None, a=None, b=None):
    """
    Parameters
    ----------
    n : int, optional
      the number of topic clusters to be generated by LDA. Default value is a
      randomly generated integer between N_MIN and N_MAX.

    a : list, optional
      1D array of length equal to number of topic clusters (n), that expresses
      our a-priori belief for the each topics’ probability. Default value is a 
      randomly generated 1D array.

    b : list, optional
      1D array of length equal to vocab_size, that expresses our a-priori belief
      for each word. Default value is a randomly generated 1D array.
    """

    if Gene.vocab_size < 1 or not isinstance(Gene.vocab_size,int):
      raise ValueError('vocab_size should be a positive integer. Set vocab_size using set_vocab_size method. The value of vocab_size was: {}'.format(Gene.vocab_size))
      
    if n is None or a is None or b is None:
      self.n = np.random.randint(self.N_MIN,self.N_MAX)
      self.a = np.random.dirichlet(np.ones(self.n), size=1)[0].tolist()
      self.b = np.random.dirichlet(np.ones(Gene.vocab_size), size=1)[0].tolist()
    else:
      if not isinstance(n, int):
        raise Exception('n should be a positive integer. \
                         The value of n was: {}'.format(n))
      self.n = n
      self.a = a
      self.b = b

  @staticmethod
  def set_vocab_size(vocab_size):
    """Sets the value of vocab_size. Must be set to a positive integer before a Gene instance can be created.

    Parameters
    ----------
    vocab_size : int
      size of vocabulary of corpus.
    """
    Gene.vocab_size = vocab_size

  @staticmethod
  def set_doc_size(doc_size):
    """Sets the value of doc_size. Must be set to a positive integer before a Gene instance can be created.

    Parameters
    ----------
    doc_size : int
      size of documents of corpus.
    """
    Gene.N_MAX = int(doc_size * .2)

  def partition_float(self, a, n):
    assert a > 0, "Gene.py partition_float: a should be positive number a= {}".format(a)
    if n == 1:
      return [a]
    pieces = []
    for i in range(n-1):
      # Assign random portion of the leftover probability to p
      p = round(random.uniform(0.00001,a-sum(pieces)-0.00001),5)
      pieces.append(p)
    # Append pieces with whatever probability left as the last element to ensure probability sum to 1
    pieces.append(a-sum(pieces))
    return pieces

  def mutate(self, mr):
    if (random.random() < mr):
      self.n = random.randint(self.N_MIN, self.N_MAX)
      # Ensure n and the size of a are the same
      if self.n != len(self.a):
        # Extract random values from dirichlet distribution for n times and form a.
        self.a = np.random.dirichlet(np.ones(self.n), size=1)[0].tolist()
    elif (random.random() < mr):
      choices = random.sample([i for i in range(len(self.a))], random.randrange(int(len(self.a)/2)))
      probs = []
      for i in sorted(choices, reverse = True):
        probs.append(self.a.pop(i))
      probs = random.shuffle(probs)
      for i,v in enumerate(sorted(choices)):
        self.a.insert(v,choices[i])
    if (random.random() < mr):
      # Extract random sample list with a random length
      choices = random.sample([i for i in range(len(self.b))], random.randrange(int(len(self.b)/2)))
      probs = []
      # Pop elements of choices in decreasing order and append it to probs list
      for i in sorted(choices, reverse = True):
        probs.append(self.b.pop(i))
      probs = random.shuffle(probs)
      # Insert from the smallest values in choices to ith position of b
      for i,v in enumerate(sorted(choices)):
        self.b.insert(v,choices[i])
    elif (random.random() < mr):
      # Extract random values from dirichlet distribution for Gene.vocab_size times and form b.
      self.b = np.random.dirichlet(np.ones(Gene.vocab_size), size=1)[0].tolist()

    assert self.n == len(self.a), "n: {}, a:{}".format(self.n, len(self.a))
    assert len(self.b) == self.vocab_size, "b: {}, v:{}".format(len(self.b), self.vocab_size)
    
    new_gene = copy.deepcopy(self)
    return new_gene

  def set_fitness(self,f):
    self.fitness = f
